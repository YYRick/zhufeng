<!-- 
   1、let和var的区别（6分）
     + let没有变量提升
     + let可以解决暂时性死区问题
     + let存在块级作用域
 -->

<!--  
   2、call、bind、apply的区别（6分）
     + 都可以改变this的指向
     + apply 和call方法一样，只是从第二个参数起，传递的形式不同,apply 是数组或者是类数组
     + bind也是处理this指向的，但是它是预处理this的指向，函数调用之后，只是预处理了里面的this，要想让fn执行，我们需要再次调用它的返回值
-->

<!-- 
   3、构造函数与普通函数执行的区别（4分）
     + 生成一个空对象赋给this
     + 隐式return this
-->

<!--  
   4、构造函数执行，如果有return会怎么样（4分） 
     + return的如果是个原始值还是默认返回this
     + return的如果是个引用值那就是返回的这个引用值
 -->

<!-- 
   5、实现一个方法，检测该属性是否是该对象的公有属性。（10分）
    Object.prototype.hasPubproperty = function hasPubproperty(attr){
        let proto = Object.getPrototypeOf(this);
        while(proto){
            if(proto.hasOwnProperty(attr)) return true;
            proto = Object.getPrototypeOf(proto);
        }
        return false;
    }
-->


<!-- 
    6、类数组转数组的三种方式（3分）
       + Array.prototype.slice.call()
       + Array.from()
       + 扩展运算符(...)
 -->
 <!-- 
   7、如何能够让类数组使用forEach方法（2分）
      转成数组
  -->

 <!-- 
   8、描述原型链的机制（4分）
    + 当我们要查找或者操作实例上的某个方法或者属性的时候，我们会先查找实例的私有属性，看看私有上是否有，如果有，停止查找；
    + 如果没有，就会基于__proto__向上查找，如果找到，就是公有属性；
    + 如果还没有，继续基于__proto原型链向上查找，直到Object基类，如果都没有，就是操作方法或者属性不存在
  -->


  <!-- 
   9、函数的三种角色（3分）
    + 普通函数
    + 构造函数(类)
    + 对象
   -->

<!-- 
  10、Object的__proto__指向哪（2分）
    + Function.prototype
-->

<!-- 
  11、手写call方法的实现原理（6分） 
-->

<!-- 
  基础编程题
  + 12 "zf" 22

  + 2 1 3 3

  + 2 1 2 1

  + zhufeng 5000 zhufeng 9 9 5000

  + 弹出 0 30

  + 2 4 1 1 2 3
 -->

 <!-- 
     1、编写一个数组去重的函数，并且可实现数组调用（7分）
     ~function(){
    function unique(){
        let obj = {},
            _this = this;
        for(let i= 0;i < _this.length ; i++){
        	let item =_this[i];
            if(obj.hasOwnProperty(item)){
                _this[i] = _this[_this.length-1];
                _this.length--;
                i--;
                continue;
            }
            obj[item] = item;
        }
        obj = null;
        return _this;
    }
    Array.prototype.unique = unique;
}();
  -->

<!-- 
2、实现数字可调用方法，plus加法与minus减法（10分）
    ~ function () {
	function checkX(x) {
		x = Number(x);
		return isNaN(x) ? 0 : x;
	}

	function plus(x) {
		x = checkX(x);
		return this + x;
	}

	function minus(x) {
		x = checkX(x);
		return this - x;
	}
	Number.prototype.plus = plus;
	Number.prototype.minus = minus;
}();
-->